import 'package:flutter/material.dart';
import '../widgets/icon_sprite.dart';

class _Stroke {
  final List<Offset> points;
  final bool isEraser;
  _Stroke(this.points, this.isEraser);
}

class IconEditorScreen extends StatefulWidget {
  final String iconKey;
  const IconEditorScreen({super.key, required this.iconKey});

  @override
  State<IconEditorScreen> createState() => _IconEditorScreenState();
}

class _IconEditorScreenState extends State<IconEditorScreen> {
  bool? isEraser;
  final List<_Stroke> _strokes = [];
  List<Offset>? _active;

  void _undoLast() {
    setState(() {
      if (_active != null && _active!.isNotEmpty) {
        _active = null;
        return;
      }
      if (_strokes.isNotEmpty) {
        _strokes.removeLast();
      }
    });
  }

  void _startStroke(Offset p) {
    setState(() => _active = [p]);
  }

  void _addPoint(Offset p) {
    final pts = _active;
    if (pts == null) return;
    setState(() => pts.add(p));
  }

  void _endStroke() {
    final pts = _active;
    if (pts == null || pts.length < 2) return;
    setState(() {
      _strokes.add(_Stroke(List<Offset>.from(pts), isEraser == true));
      _active = null;
    });
  }

  double _strokeWidth(double canvasSize) {
    final base = (canvasSize * 0.024).clamp(2.0, 8.0);
    if (isEraser == true) return (base + 2.0).clamp(2.0, 10.0);
    return base;
  }

  String sheetForKey(String iconKey) {
    if (iconKey.startsWith('T')) return 'assets/icons/icons_t.png';
    if (iconKey.startsWith('L')) return 'assets/icons/icons_l.png';
    return 'assets/icons/icons_r.png';
  }

  int indexForKey(String iconKey) {
    final trail = (iconKey.length >= 2) ? iconKey.substring(iconKey.length - 2) : '';
    final num = int.tryParse(trail) ?? 1;
    return (num - 1).clamp(0, 8);
  }

  @override
  Widget build(BuildContext context) {
    final iconKey = widget.iconKey;
    final primary = Theme.of(context).colorScheme.primary;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Icon'),
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.pop(context),
        ),
        actions: const [],
      ),      bottomNavigationBar: SafeArea(
        top: false,
        child: BottomAppBar(
          child: Padding(
            padding: const EdgeInsets.fromLTRB(10, 8, 10, 10),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    IconButton(
                      iconSize: 30,
                      tooltip: 'Undo',
                      icon: const Icon(Icons.undo),
                      onPressed: _undoLast,
                    ),
                    const SizedBox(width: 14),
                    IconButton(
                      iconSize: 34,
                      tooltip: 'Eraser',
                      icon: Icon(
                        Icons.auto_fix_off,
                        color: (isEraser == true)
                            ? Theme.of(context).colorScheme.onPrimary
                            : null,
                      ),
                      style: ButtonStyle(
                        backgroundColor: (isEraser == true)
                            ? WidgetStateProperty.all(
                                Theme.of(context).colorScheme.primary)
                            : null,
                      ),
                      onPressed: () => setState(() => isEraser = true),
                    ),
                    const SizedBox(width: 14),
                    IconButton(
                      iconSize: 34,
                      tooltip: 'Pencil',
                      icon: Icon(
                        Icons.edit,
                        color: (isEraser == false)
                            ? Theme.of(context).colorScheme.onPrimary
                            : null,
                      ),
                      style: ButtonStyle(
                        backgroundColor: (isEraser == false)
                            ? WidgetStateProperty.all(
                                Theme.of(context).colorScheme.primary)
                            : null,
                      ),
                      onPressed: () => setState(() => isEraser = false),
                    ),
                  ],
                ),
                const SizedBox(height: 10),
                Align(
                  alignment: Alignment.centerRight,
                  child: IconButton(
                    iconSize: 30,
                    tooltip: 'Save',
                    icon: const Icon(Icons.save),
                    onPressed: () => Navigator.pop(context, iconKey),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: LayoutBuilder(
            builder: (context, constraints) {
              final size = constraints.maxWidth;
              return Column(
                children: [
                    Expanded(
                      child: Center(
                      child: AspectRatio(
                        aspectRatio: 1,
                      child: ClipRect(
                        child: Stack(
                          children: [
                              Positioned.fill(
                              child: IgnorePointer(
                                  ignoring: true,
                                child: Container(
                                  decoration: BoxDecoration(
                                  border: Border.all(width: 1),
                                  ),
                                ),
                              ),
                            ),
                            Positioned.fill(
                              child: Center(
                                child: IconSprite(
                                  assetPath: sheetForKey(iconKey),
                                  index0: indexForKey(iconKey),
                                    size: size,
                                    padding: 6,
                                  ),
                              ),
                           ),
                            Positioned.fill(
                              child: GestureDetector(
                                onPanStart: (d) {
                                    if (isEraser == null) return;
                                    _startStroke(d.localPosition);
                                },
                                onPanUpdate: (d) {
                                    if (isEraser == null) return;
                                    _addPoint(d.localPosition);
                                },
                                onPanEnd: (_) {
                                    if (isEraser == null) return;
                                    _endStroke();
                                },
                                child: CustomPaint(
                                painter: _StrokePainter(
                                  strokes: _strokes,
                                    active: _active,
                                    strokeWidth: _strokeWidth(size),
                                    activeIsEraser: isEraser == true,
                                  ),
                                child: const SizedBox.expand(),
                              ),
                           ),
                          ),
                          ],
                        ),
                       ),
                    ),
                   ),
                ),
                  const SizedBox(height: 12),
                Text('Base icon: $iconKey', style: const TextStyle(fontWeight: FontWeight.w700)),
              ],
           );
          },
          ),
        ),
      ),
    );
  }
}

class _StrokePainter extends CustomPainter {
  final List<_Stroke> strokes;
  final List<Offset>? active;
  final double strokeWidth;
  final bool activeIsEraser;
  _StrokePainter({
    required this.strokes,
    required this.active,
    required this.strokeWidth,
    required this.activeIsEraser,
  });

  @override
  void paint(Canvas canvas, Size size) {
    for (final s in strokes) {
      _draw(canvas, s.points, s.isEraser);
    }
    final a = active;
    if (a != null && a.length >= 2) {
      _draw(canvas, a, activeIsEraser);
    }
  }

  void _draw(Canvas canvas, List<Offset> pts, bool eraser) {
    if (pts.length < 2) return;

    final paint = Paint()
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round
      ..strokeJoin = StrokeJoin.round
      ..strokeWidth = strokeWidth;

    if (eraser) {
      paint.blendMode = BlendMode.clear;
      paint.color = Colors.transparent;
    } else {
      paint.color = Colors.black;
    }

    final path = Path()..moveTo(pts[0].dx, pts[0].dy);
    for (var i = 1; i < pts.length; i++) {
      path.lineTo(pts[i].dx, pts[i].dy);
    }
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant _StrokePainter oldDelegate) {
    return oldDelegate.strokes != strokes ||
        oldDelegate.active != active ||
        oldDelegate.strokeWidth != strokeWidth;
  }
}
